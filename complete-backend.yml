AWSTemplateFormatVersion: '2010-09-09'
Description: 'Complete Vehicle Guesser Backend Infrastructure'

Parameters:
  Environment:
    Type: String
    Default: prod
    Description: Environment name
  
  UserPoolId:
    Type: String
    Description: Cognito User Pool ID from cognito stack

Resources:
  # DynamoDB Table for Game Data
  GameDataTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub 'vehicle-guesser-gamedata-${Environment}'
      AttributeDefinitions:
        - AttributeName: userId
          AttributeType: S
      KeySchema:
        - AttributeName: userId
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      SSESpecification:
        SSEEnabled: true

  # Lambda Execution Role
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'vehicle-guesser-lambda-role-${Environment}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Scan
                  - dynamodb:Query
                Resource: !GetAtt GameDataTable.Arn

  # Lambda Function
  ApiLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'vehicle-guesser-api-${Environment}'
      Runtime: nodejs18.x
      Handler: cognito-index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
          const { DynamoDBDocumentClient, GetCommand, PutCommand, ScanCommand } = require('@aws-sdk/lib-dynamodb');
          
          const client = new DynamoDBClient({ region: process.env.AWS_REGION || 'eu-west-1' });
          const dynamodb = DynamoDBDocumentClient.from(client);
          
          const corsHeaders = {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
            'Content-Type': 'application/json'
          };
          
          exports.handler = async (event) => {
            console.log('Event:', JSON.stringify(event, null, 2));
          
            try {
              const { httpMethod, path, body } = event;
              
              if (httpMethod === 'OPTIONS') {
                return {
                  statusCode: 200,
                  headers: corsHeaders,
                  body: ''
                };
              }
          
              const userId = event.requestContext?.authorizer?.claims?.sub;
              if (!userId) {
                return {
                  statusCode: 401,
                  headers: corsHeaders,
                  body: JSON.stringify({ error: 'Unauthorized' })
                };
              }
          
              if (path === '/gamedata') {
                if (httpMethod === 'GET') {
                  return await getGameData(userId);
                } else if (httpMethod === 'POST') {
                  return await updateGameData(userId, JSON.parse(body));
                }
              }
          
              if (path === '/leaderboard' && httpMethod === 'GET') {
                return await getLeaderboard();
              }
          
              if (path.startsWith('/images/') && httpMethod === 'GET') {
                return await getVehicleImage(path);
              }
          
              return {
                statusCode: 404,
                headers: corsHeaders,
                body: JSON.stringify({ error: 'Not found' })
              };
          
            } catch (error) {
              console.error('Lambda error:', error);
              return {
                statusCode: 500,
                headers: corsHeaders,
                body: JSON.stringify({ error: 'Internal server error' })
              };
            }
          };
          
          async function getGameData(userId) {
            try {
              const result = await dynamodb.send(new GetCommand({
                TableName: process.env.GAME_DATA_TABLE,
                Key: { userId }
              }));
          
              const gameData = result.Item || {
                userId,
                stats: {
                  highScore: 0,
                  enduranceHighScore: 0,
                  gamesPlayed: 0,
                  totalPoints: 0,
                  difficultyPlays: { Easy: 0, Medium: 0, Hard: 0 },
                  gears: 20,
                  xp: 0,
                  level: 1,
                  powerUps: { timeFreeze: 0, clueGiver: 0 },
                  correctAnswers: 0,
                  incorrectAnswers: 0,
                  perfectRounds: 0,
                  gameHistory: [],
                  lastBonusDate: '',
                  loginStreak: 0,
                  journeyProgress: {}
                },
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
              };
          
              if (!gameData.stats.gears) gameData.stats.gears = 20;
              if (!gameData.stats.xp) gameData.stats.xp = 0;
              if (!gameData.stats.level) gameData.stats.level = 1;
              if (!gameData.stats.powerUps) gameData.stats.powerUps = { timeFreeze: 0, clueGiver: 0 };
              if (!gameData.stats.journeyProgress) gameData.stats.journeyProgress = {};
          
              return {
                statusCode: 200,
                headers: corsHeaders,
                body: JSON.stringify(gameData)
              };
            } catch (error) {
              console.error('Get game data error:', error);
              return {
                statusCode: 500,
                headers: corsHeaders,
                body: JSON.stringify({ error: 'Failed to get game data' })
              };
            }
          }
          
          async function updateGameData(userId, gameData) {
            try {
              const existing = await dynamodb.send(new GetCommand({
                TableName: process.env.GAME_DATA_TABLE,
                Key: { userId }
              }));
          
              const currentData = existing.Item || {
                userId,
                stats: {
                  highScore: 0,
                  enduranceHighScore: 0,
                  gamesPlayed: 0,
                  totalPoints: 0,
                  difficultyPlays: { Easy: 0, Medium: 0, Hard: 0 },
                  gears: 20,
                  xp: 0,
                  level: 1,
                  powerUps: { timeFreeze: 0, clueGiver: 0 },
                  correctAnswers: 0,
                  incorrectAnswers: 0,
                  perfectRounds: 0,
                  gameHistory: [],
                  lastBonusDate: '',
                  loginStreak: 0,
                  journeyProgress: {}
                },
                createdAt: new Date().toISOString()
              };
          
              if (!currentData.stats.gears) currentData.stats.gears = 20;
              if (!currentData.stats.xp) currentData.stats.xp = 0;
              if (!currentData.stats.level) currentData.stats.level = 1;
              if (!currentData.stats.powerUps) currentData.stats.powerUps = { timeFreeze: 0, clueGiver: 0 };
              if (!currentData.stats.journeyProgress) currentData.stats.journeyProgress = {};
          
              const { score, mode, level, mistakes = 0, isEndurance = false, bonusData, journeyData, hintCost, powerUpType, purchaseData } = gameData;
              
              if (mode === 'bonus' && bonusData) {
                currentData.stats.gears += bonusData.gears;
                currentData.stats.lastBonusDate = bonusData.lastBonusDate;
                currentData.stats.loginStreak = bonusData.loginStreak;
              } else if (mode === 'hint' && hintCost) {
                currentData.stats.gears = Math.max(0, currentData.stats.gears - hintCost);
              } else if (mode === 'powerup' && powerUpType) {
                if (currentData.stats.powerUps[powerUpType] > 0) {
                  currentData.stats.powerUps[powerUpType] -= 1;
                }
              } else if (mode === 'purchase' && purchaseData) {
                const { powerUp, cost } = purchaseData;
                if (currentData.stats.gears >= cost) {
                  currentData.stats.gears -= cost;
                  currentData.stats.powerUps[powerUp] = (currentData.stats.powerUps[powerUp] || 0) + 1;
                }
              } else {
                currentData.stats.gamesPlayed += 1;
                currentData.stats.totalPoints += score;
                currentData.stats.difficultyPlays[level] = (currentData.stats.difficultyPlays[level] || 0) + 1;
                
                if (isEndurance) {
                  currentData.stats.enduranceHighScore = Math.max(currentData.stats.enduranceHighScore, score);
                } else {
                  currentData.stats.highScore = Math.max(currentData.stats.highScore, score);
                }
                
                currentData.stats.correctAnswers += Math.floor(score / 25);
                currentData.stats.incorrectAnswers += mistakes;
                
                const isPerfectGame = !isEndurance && mistakes === 0;
                if (isPerfectGame) {
                  currentData.stats.perfectRounds += 1;
                }
                
                const baseXp = Math.floor(score / 10);
                const timeBonus = Math.max(0, Math.floor((score % 1000) / 100));
                const xpGained = baseXp + timeBonus + (isPerfectGame ? 25 : 0);
                
                const baseGears = Math.floor(score / 50);
                const gearsGained = baseGears + (isPerfectGame ? 10 : 0);
                
                const XP_PER_LEVEL = 500;
                const GEARS_PER_LEVEL_UP = 25;
                
                let newXp = currentData.stats.xp + xpGained;
                let newLevel = currentData.stats.level;
                let newGears = currentData.stats.gears + gearsGained;
                
                if (newXp >= XP_PER_LEVEL) {
                  const levelsGained = Math.floor(newXp / XP_PER_LEVEL);
                  newLevel += levelsGained;
                  newXp = newXp % XP_PER_LEVEL;
                  newGears += (GEARS_PER_LEVEL_UP * levelsGained);
                }
                
                currentData.stats.xp = newXp;
                currentData.stats.level = newLevel;
                currentData.stats.gears = newGears;
                
                if (mode === 'Journey' && journeyData) {
                  const { levelId, stars, completed, score: journeyScore } = journeyData;
                  const existing = currentData.stats.journeyProgress[levelId];
                  
                  if (!existing || existing.score < journeyScore) {
                    currentData.stats.journeyProgress[levelId] = {
                      stars,
                      score: journeyScore,
                      completed
                    };
                  }
                }
                
                currentData.stats.gameHistory.unshift({
                  id: Date.now().toString(),
                  date: new Date().toLocaleDateString(),
                  mode,
                  level,
                  score,
                  timestamp: new Date().toISOString()
                });
                
                currentData.stats.gameHistory = currentData.stats.gameHistory.slice(0, 10);
              }
              currentData.updatedAt = new Date().toISOString();
          
              await dynamodb.send(new PutCommand({
                TableName: process.env.GAME_DATA_TABLE,
                Item: currentData
              }));
          
              return {
                statusCode: 200,
                headers: corsHeaders,
                body: JSON.stringify(currentData)
              };
            } catch (error) {
              console.error('Update game data error:', error);
              return {
                statusCode: 500,
                headers: corsHeaders,
                body: JSON.stringify({ error: 'Failed to update game data' })
              };
            }
          }
          
          async function getLeaderboard() {
            try {
              const result = await dynamodb.send(new ScanCommand({
                TableName: process.env.GAME_DATA_TABLE
              }));
          
              const leaderboard = result.Items
                .map(item => ({
                  username: item.username || 'Anonymous',
                  highScore: item.stats.highScore || 0,
                  level: item.stats.level || 1,
                  gamesPlayed: item.stats.gamesPlayed || 0
                }))
                .sort((a, b) => b.highScore - a.highScore)
                .slice(0, 10)
                .map((user, index) => ({
                  rank: index + 1,
                  ...user
                }));
          
              return {
                statusCode: 200,
                headers: corsHeaders,
                body: JSON.stringify(leaderboard)
              };
            } catch (error) {
              console.error('Get leaderboard error:', error);
              return {
                statusCode: 500,
                headers: corsHeaders,
                body: JSON.stringify({ error: 'Failed to get leaderboard' })
              };
            }
          }
          
          async function getVehicleImage(path) {
            try {
              const imageKey = path.replace('/images/', '');
              const s3Url = `https://vehicle-guesser-1764962592.s3.eu-west-1.amazonaws.com/images/${imageKey}`;
              
              return {
                statusCode: 302,
                headers: {
                  ...corsHeaders,
                  'Location': s3Url,
                  'Cache-Control': 'public, max-age=86400'
                }
              };
            } catch (error) {
              console.error('Get image error:', error);
              return {
                statusCode: 404,
                headers: corsHeaders,
                body: JSON.stringify({ error: 'Image not found' })
              };
            }
          }
      Environment:
        Variables:
          GAME_DATA_TABLE: !Ref GameDataTable
          USER_POOL_ID: !Ref UserPoolId
          NODE_ENV: !Ref Environment
      Timeout: 30

  # API Gateway
  ApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub 'vehicle-guesser-api-${Environment}'
      Description: Vehicle Guesser Game API
      EndpointConfiguration:
        Types:
          - REGIONAL

  # Cognito Authorizer
  CognitoAuthorizer:
    Type: AWS::ApiGateway::Authorizer
    Properties:
      Name: CognitoAuthorizer
      Type: COGNITO_USER_POOLS
      IdentitySource: method.request.header.Authorization
      RestApiId: !Ref ApiGateway
      ProviderARNs:
        - !Sub 'arn:aws:cognito-idp:${AWS::Region}:${AWS::AccountId}:userpool/${UserPoolId}'

  # API Gateway Resources
  GameDataResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: gamedata

  LeaderboardResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: leaderboard

  ImagesResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: images

  ImagesProxyResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ImagesResource
      PathPart: '{proxy+}'

  # API Gateway Methods
  GameDataGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref GameDataResource
      HttpMethod: GET
      AuthorizationType: COGNITO_USER_POOLS
      AuthorizerId: !Ref CognitoAuthorizer
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ApiLambdaFunction.Arn}/invocations'

  GameDataPostMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref GameDataResource
      HttpMethod: POST
      AuthorizationType: COGNITO_USER_POOLS
      AuthorizerId: !Ref CognitoAuthorizer
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ApiLambdaFunction.Arn}/invocations'

  LeaderboardGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref LeaderboardResource
      HttpMethod: GET
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ApiLambdaFunction.Arn}/invocations'

  # CORS Options Methods
  GameDataOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref GameDataResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ApiLambdaFunction.Arn}/invocations'

  LeaderboardOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref LeaderboardResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ApiLambdaFunction.Arn}/invocations'

  ImagesGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ImagesProxyResource
      HttpMethod: GET
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ApiLambdaFunction.Arn}/invocations'

  ImagesOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ImagesProxyResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ApiLambdaFunction.Arn}/invocations'

  # Lambda Permissions
  ApiGatewayInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ApiLambdaFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*/*'

  # API Gateway Deployment
  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - GameDataGetMethod
      - GameDataPostMethod
      - LeaderboardGetMethod
      - GameDataOptionsMethod
      - LeaderboardOptionsMethod
      - ImagesGetMethod
      - ImagesOptionsMethod
    Properties:
      RestApiId: !Ref ApiGateway
      StageName: !Ref Environment

Outputs:
  ApiGatewayUrl:
    Description: API Gateway URL
    Value: !Sub 'https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/${Environment}'
    Export:
      Name: !Sub '${AWS::StackName}-ApiUrl'

  GameDataTableName:
    Description: DynamoDB Table Name
    Value: !Ref GameDataTable
    Export:
      Name: !Sub '${AWS::StackName}-TableName'

  LambdaFunctionName:
    Description: Lambda Function Name
    Value: !Ref ApiLambdaFunction
    Export:
      Name: !Sub '${AWS::StackName}-LambdaName'